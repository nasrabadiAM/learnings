ترد چیست؟
---
<p dir="rtl">
ترد یکی از مفاهیم جاوا است و درواقع به مسیری (path of execution) که یک تکه کد از بالا به پایین به صورت متوالی اجرا می‌شود، می‌گوییم.
</p>

<p dir="rtl">
  هر برنامه جاوا حداقل یک ترد به نام 
  mainThread
  دارد و متد 
  main 
  برنامه در ترد 
  main
  ای که 
  JVM
  اجرا می‌کند، صدا زده می‌شود.
</p>

<p dir="rtl">
  ترد‌های دیگری هم  توسط 
 JVM 
  اجرا می‌شوند که معمولا ما متوجه آن‌ها نمی‌شویم، مثلا تردهایی مربوط به 
  GC 
  یا 
  Object Finalization
  و ...
</p>


<p dir="rtl">
کلاس ترد در java.lang.Thread تعریف شده است.
</p>

<p dir="rtl">
ترد‌ها با پراسس‌ها و کانکشن‌ها متفاوت‌اند. 
</p>

<p dir="rtl">
از مزایای ترد‌ها این است که می‌توانیم به صورت مجازی parallelism یا همان concurrency داشته باشیم.
اما معایب خودش را هم دارد و باید درجای مناسب و به درستی استفاده شود. مثلا اگر برای یک کار کوچک از چندین ترد استفاده کنیم، مطمئنا کارایی پایینتری خواهیم داشت چرا که ساخت ترد و یا پایان دادن به آن خود کار زمان‌بری است.
</p>


<p dir="rtl">
  تردینگ علاوه بر مزایایی که دارد، ریسک‌هایی را نیز همراه با خود به وجود می‌آورد.
  مثلا زمانیکه یک فیلد استاتیک داریم یا یک کالکشن دیتا داریم، باید مطمئن شویم که هر ترد یک نمای درست از داده‌ها را می‌بیند و از آن استفاده می‌کند.
</p>
</br>

<p dir="rtl"><b>مشکلات تردینگ و راه‌حل‌ها</b></p>
<p dir="rtl">
  در کل 
  Shared Mutable Data
  ها باعث ایجاد 
  inconsistency 
  در برنامه و داده‌های موجود می‌شوند.
  برای آنکه 
  cpu  
  عملیاتی را روی داده‌ای انجام دهد، باید سه کار را انجام دهد، ابتدا آن را از حافظه خوانده و در رجیستر خودش قرار دهد، سپس عملیات را انجام دهد و در انتها جواب را در حافظه بنویسد.
  این 
  inconsistency
   به این دلیل می‌افتد که در کامپایلر و پردازنده سیستم
  Optimization
  هایی انجام می‌شود تا زمانی که مثلا قرار است یک ترد یک عدد را ۱۰۰ بار افزایش دهد، هر بار این پروسه خواندن، انجام عملیات و نوشتن روی حافظه را انجام ندهد و به جای آن یک بار بخوانند، ۱۰۰ بار به متغیرر اضافه کند و بعد آن را روی مموری بنویسد.
  حالا اگر در این بین و زمانی که ترد قبلی درحال اضافه کردن به متغیر هست،تردی دیگر آن عدد را از مموری بخواند، عدد اشتباه را خوانده  این باعث ایجاد 
  inconsistency
  در برنامه ما و داده‌های موجود در آن می‌شود.
</p>


<p dir="rtl">
برای آنکه این ناهماهنگی و تداخل بین ترد‌ها ایجاد نشود، باید از
   <b>volatile</b>  
  یا
  <b>synchronized</b>
  استفاده کنیم.
</p>



<p dir="rtl">
  زبان جاوا برای اشتراک درست داده‌ها بین ترد‌ها از دوکلمه کلیدی بالا استفاده می‌کند.
</p>

<p dir="rtl">
  کلمه 
  Synchronized
  دو معنی می‌دهد:
  اول آنکه در هر لحظه فقط به یک ترد اجازه استفاده از یک بلاک از کد را می‌دهد، همچنین اطمینان حاصل می‌کند که اطلاعات تغییر یافته توسط یک ترد برای دیگر ترد‌ها قابل دیدن باشد.
</p>

<p dir="rtl">
با استفاده از کلمه 
  volatile 
  می‌توانیم دسترسی به یک رفرنس از متغیر‌های اولیه 
  (primitive variables like int, double, ...)
  را کنترل کنیم.
  زمانیکه یک متغیر را 
  volatile 
  تعریف می‌کنیم، هر تغییری روی آن متغیر مستقیما روی مموری اصلی اعمال می‌شود.
</p>

<p dir="rtl">
هر آبجکت در جاوا یک 
  lock 
  برای خود دارد.
  این lock
  ها در هر زمان فقط توسط یک ترد می‌توانند نگه داشته شوند.
  زمانیکه یک ترد وارد یک بلاک 
  synchronized 
  می‌شود، ابتدا صبر می‌کند تا 
  lock 
  در دسترس قرار بگیرد، زمانیکه لاک در دسترس قرار گرفت، آن را می‌گیرد و سپس آن بلاک از کد را اجرا می‌کند.
  سپس زمانیکه از آن بلاک از کد خارج شد، یا اکسپشنی رخ داد، لاک را آزاد می‌کند.
</p>


<p dir="rtl"><b>زندگی یک ترد</b></p>
<p dir="rtl">
</p>

<p dir="rtl">
  برای ساخت یک ترد دو روش وجود دارد، روش اول آنکه کلاسی را از کلاس ترد 
  extend 
  کنیم و روش دوم اینکه آبجکتی از خود ترد بسازیم.
  بهتر است در کانستراکتور کلاس‌ها متد استارت را صدا نزنیم، زیرا ممکن است باعث ساخته‌شدن یک سری آبکت اضافه در ترد جدید شود.
</p>

<p dir="rtl">
  ترد‌ها شروع به کار نمی‌کنند، مگر آنکه متد 
  start()
  آن‌ها توسط تردی دیگر صدا زده شود.
</p>

<p dir="rtl"><b>
  یک ترد در سه صورت از بین می‌رود:
</b></p>
<ul dir="rtl">
      <li>ترد به انتهای متد run()  خود برسد</li>
      <li>ترد به یک اکسپشن هتدل نشده برخورد کند</li>
      <li>یک ترد دیگر یکی از متد‌های منسوخ شده stop()  را صدا بزند</li>
</ul>


<p dir="rtl">
با استفاده از متد 
  join 
  در ترد‌ها می‌توانیم به یک ترد بگوییم که تا اتمام تردی دیگر صبر کند.
  معمولا از 
  join 
  در برنامه‌هایی که یک کار بزرگ را بین چند ترد تقسیم می‌کنند، استفاده می‌کنیم.
</p>

```java
Thread.join();
```

<p dir="rtl">
  در این حالت ترد اول تا تمام شدن ترد دوم 
  stop
  می‌شود و بعد از اتمام آن ادامه کار خود را انجام می‌دهد.
</p>

<p dir="rtl">
  نکته دیگری که درباره تردها وجود دارد این است که هیچگاه نمی‌توانیم انتظار داشته باشیم که یک ترد زودتر از دیگری اجرا شود، حتی زمانی که تردی را بعد از ترد دیگری اجرا می‌کنیم.
  مگر آنکه از خودمان از طریق 
  Thread.join()
  یا 
  Object.wait()
  استفاده کنیم.
</p>

<p dir="rtl">
  با استفاده از 
  Thread.sleep()
   می‌توانیم یک ترد را تا یک زمان مشخص متوقف کنیم. پس از گذشت مقدار ثانیه‌ای که می‌خواستیم، ترد دوباره شروع به اداه انجام کار خود می‌کند.
  مگر آنکه متد 
  Thread.intrupt() 
  صدا زده شود.
</p>


<p dir="rtl">
  متد 
  Thread.yield()
  هم همانند 
  sleep()  
است، با این تفاوت که به جای آنکه ترد را 
  sleep
  کند، ترد را موقتا 
  pause 
  می‌کند.
  بنابراین بقیه ترد‌ها می‌توانند اجرا شوند.
</p>


<p dir="rtl">
  متد 
  yield
  کمی با 
  sleep 
  و 
  wait 
  متفاوت است.
  کاری که می‌کند این است که ترد فعلی را از 
  cpu  
  می‌گیرد تا شانسی برای دیگر ترد‌ها برای اجرا ایجاد شود. 
  اما هیچ تضمینی وجود ندارد که کدام ترد اجرا خواهد شد. شاید حتی دوباره همان ترد قبلی اجرا شود و این موضوع به 
  Thread Scheduler 
  بستگی دارد.
</p>


<p dir="rtl">
  تفاوت 
  sleep 
  با 
  wait 
  در این است که متد 
  wait 
  بیشتر برای 
  inter-thread commiunication
  ها استفاده می‌شود به این صورت که، زمانیکه تردی یک 
  Mutable Shared data 
  را تغییر می‌دهد، ابتدا قبل از تغییر بقیه ترد‌ها را 
  wait
  کرده و پس از آنکه تغییرات را انجام داد، بقیه را 
  notify 
  کرده و با این کار می‌گوید که تغییری در داده‌های اشتراکی انجام شده که ممکن است برایتان جالب باشد.
 اما 
  sleep 
  برای متوقف کردن موقتی ترد استفاده می‌شود
</p>

<p dir="rtl">
  این تغییر زمانی واضح مشخص می‌شود که بفهمیم زمانیکه تردی
   wait 
  را صدا می‌زند، لاک یا مانیتوری که برروی آبجکت دارد را آزاد می‌کند اما زمانی که متد 
  sleep 
  از تردی 
  صدا زده می‌شود، به هیچ وجه مانیتور خود را آزاد نمی کند.
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

////کل منبع اول خوانده شده و درمورد ترد کامل یادبگیر.


منابع
---

https://www.ibm.com/developerworks/java/tutorials/j-threads/j-threads.html

https://www.geeksforgeeks.org/main-thread-java/

https://www.tutorialspoint.com/java_concurrency/index.htm
