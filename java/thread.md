ترد چیست؟
---
<p dir="rtl">
ترد یکی از مفاهیم جاوا است و درواقع به مسیری (path of execution) که یک تکه کد از بالا به پایین به صورت متوالی اجرا می‌شود، می‌گوییم.
</p>

<p dir="rtl">
  هر برنامه جاوا حداقل یک ترد به نام 
  mainThread
  دارد و متد 
  main 
  برنامه در ترد 
  main
  ای که 
  JVM
  اجرا می‌کند، صدا زده می‌شود.
</p>

<p dir="rtl">
  ترد‌های دیگری هم  توسط 
 JVM 
  اجرا می‌شوند که معمولا ما متوجه آن‌ها نمی‌شویم، مثلا تردهایی مربوط به 
  GC 
  یا 
  Object Finalization
  و ...
</p>


<p dir="rtl">
کلاس ترد در java.lang.Thread تعریف شده است.
</p>

<p dir="rtl">
ترد‌ها با پراسس‌ها و کانکشن‌ها متفاوت‌اند. 
</p>

<p dir="rtl">
از مزایای ترد‌ها این است که می‌توانیم به صورت مجازی parallelism یا همان concurrency داشته باشیم.
اما معایب خودش را هم دارد و باید درجای مناسب و به درستی استفاده شود. مثلا اگر برای یک کار کوچک از چندین ترد استفاده کنیم، مطمئنا کارایی پایینتری خواهیم داشت چرا که ساخت ترد و یا پایان دادن به آن خود کار زمان‌بری است.
</p>


<p dir="rtl"><b>
  اشتراک اطلاعات بین ترد‌ها
</b></p>

<p dir="rtl">
برای آکه اطلاعاتی را بین ترد‌ها جابجا کنیم، از 
  Shared Variable (static, instance fields)
  ها استفاده می‌کنیم.
</p>

<p dir="rtl">
  تردینگ علاوه بر مزایایی که دارد، ریسک‌هایی را نیز همراه با خود به وجود می‌آورد.
  مثلا زمانیکه یک فیلد استاتیک داریم یا یک کالکشن دیتا داریم، باید مطمئن شویم که هر ترد یک نمای درست از داده‌ها را می‌بیند و از آن استفاده می‌کند.
</p>
</br>

<p dir="rtl"><b>مشکلات تردینگ و راه‌حل‌ها</b></p>
<p dir="rtl">
  در کل 
  Shared Mutable Data
  ها باعث ایجاد 
  inconsistency 
  در برنامه و داده‌های موجود می‌شوند.
  برای آنکه 
  cpu  
  عملیاتی را روی داده‌ای انجام دهد، باید سه کار را انجام دهد، ابتدا آن را از حافظه خوانده و در رجیستر خودش قرار دهد، سپس عملیات را انجام دهد و در انتها جواب را در حافظه بنویسد.
  این 
  inconsistency
   به این دلیل می‌افتد که در کامپایلر و پردازنده سیستم
  Optimization
  هایی انجام می‌شود تا زمانی که مثلا قرار است یک ترد یک عدد را ۱۰۰ بار افزایش دهد، هر بار این پروسه خواندن، انجام عملیات و نوشتن روی حافظه را انجام ندهد و به جای آن یک بار بخوانند، ۱۰۰ بار به متغیرر اضافه کند و بعد آن را روی مموری بنویسد.
  حالا اگر در این بین و زمانی که ترد قبلی درحال اضافه کردن به متغیر هست،تردی دیگر آن عدد را از مموری بخواند، عدد اشتباه را خوانده  این باعث ایجاد 
  inconsistency
  در برنامه ما و داده‌های موجود در آن می‌شود.
</p>

<p dir="rtl">
برای آنکه این ناهماهنگی و تداخل بین ترد‌ها ایجاد نشود، باید از
   <b>volatile</b>  
  یا
  <b>synchronized</b>
  استفاده کنیم.
</p>

<p dir="rtl">
  زبان جاوا برای اشتراک درست داده‌ها بین ترد‌ها از دوکلمه کلیدی بالا استفاده می‌کند.
</p>

<p dir="rtl">
  کلمه 
  Synchronized
  دو معنی می‌دهد:
  اول آنکه در هر لحظه فقط به یک ترد اجازه استفاده از یک بلاک از کد را می‌دهد، همچنین اطمینان حاصل می‌کند که اطلاعات تغییر یافته توسط یک ترد برای دیگر ترد‌ها قابل دیدن باشد.
</p>

<p dir="rtl">
با استفاده از کلمه 
  volatile 
  می‌توانیم دسترسی به یک رفرنس از متغیر‌های اولیه 
  (primitive variables like int, double, ...)
  را کنترل کنیم.
  زمانیکه یک متغیر را 
  volatile 
  تعریف می‌کنیم، هر تغییری روی آن متغیر مستقیما روی مموری اصلی اعمال می‌شود.
</p>

<p dir="rtl">
هر آبجکت در جاوا یک 
  lock 
  برای خود دارد.
  این lock
  ها در هر زمان فقط توسط یک ترد می‌توانند نگه داشته شوند.
  زمانیکه یک ترد وارد یک بلاک 
  synchronized 
  می‌شود، ابتدا صبر می‌کند تا 
  lock 
  در دسترس قرار بگیرد، زمانیکه لاک در دسترس قرار گرفت، آن را می‌گیرد و سپس آن بلاک از کد را اجرا می‌کند.
  سپس زمانیکه از آن بلاک از کد خارج شد، یا اکسپشنی رخ داد، لاک را آزاد می‌کند.
</p>


<p dir="rtl"><b>زندگی یک ترد</b></p>
<p dir="rtl">
</p>

<p dir="rtl">
  برای ساخت یک ترد دو روش وجود دارد، روش اول آنکه کلاسی را از کلاس ترد 
  extend 
  کنیم و روش دوم اینکه آبجکتی از خود ترد بسازیم.
  بهتر است در کانستراکتور کلاس‌ها متد استارت را صدا نزنیم، زیرا ممکن است باعث ساخته‌شدن یک سری آبکت اضافه در ترد جدید شود.
</p>

<p dir="rtl">
  ترد‌ها شروع به کار نمی‌کنند، مگر آنکه متد 
  start()
  آن‌ها توسط تردی دیگر صدا زده شود.
</p>

<p dir="rtl"><b>
  یک ترد در سه صورت از بین می‌رود:
</b></p>
<ul dir="rtl">
      <li>ترد به انتهای متد run()  خود برسد</li>
      <li>ترد به یک اکسپشن هتدل نشده برخورد کند</li>
      <li>یک ترد دیگر یکی از متد‌های منسوخ شده stop()  را صدا بزند</li>
</ul>


<p dir="rtl">
با استفاده از متد 
  join 
  در ترد‌ها می‌توانیم به یک ترد بگوییم که تا اتمام تردی دیگر صبر کند.
  معمولا از 
  join 
  در برنامه‌هایی که یک کار بزرگ را بین چند ترد تقسیم می‌کنند، استفاده می‌کنیم.
</p>

```java
Thread.join();
```
<p dir="rtl">
  در واقع کار 
  join 
  این است که به تردی که تردی دیگر را می‌سازد، بگوییم تا زمانیکه تردی که ساخته‌ای تمام نشده، حق نداری تمام شوی.
</p>

<p dir="rtl">
نکته‌ای دیگری که وجود دارد این است که حتما باید 
  join
  را بعد از  
  start
  کردن ترد صدا بزنیم وگرنه اگر قبل از 
  start 
  شدن ترد صدا زده شود، چون ترد هنوز اجرا نشده در همان لحظه از 
  join 
  بیرون می‌آید.
</p>


<p dir="rtl">
  در این حالت ترد اول تا تمام شدن ترد دوم 
  stop
  می‌شود و بعد از اتمام آن ادامه کار خود را انجام می‌دهد.
</p>

<p dir="rtl">
  نکته دیگری که درباره تردها وجود دارد این است که هیچگاه نمی‌توانیم انتظار داشته باشیم که یک ترد زودتر از دیگری اجرا شود، حتی زمانی که تردی را بعد از ترد دیگری اجرا می‌کنیم.
  مگر آنکه از خودمان از طریق 
  Thread.join()
  یا 
  Object.wait()
  استفاده کنیم.
</p>

<p dir="rtl">
  با استفاده از 
  Thread.sleep()
   می‌توانیم یک ترد را تا یک زمان مشخص متوقف کنیم. پس از گذشت مقدار ثانیه‌ای که می‌خواستیم، ترد دوباره شروع به اداه انجام کار خود می‌کند.
  مگر آنکه متد 
  Thread.intrupt() 
  صدا زده شود.
</p>


<p dir="rtl">
  متد 
  Thread.yield()
  هم همانند 
  sleep()  
است، با این تفاوت که به جای آنکه ترد را 
  sleep
  کند، ترد را موقتا 
  pause 
  می‌کند.
  بنابراین بقیه ترد‌ها می‌توانند اجرا شوند.
</p>


<p dir="rtl">
  متد 
  yield
  کمی با 
  sleep 
  و 
  wait 
  متفاوت است.
  کاری که می‌کند این است که ترد فعلی را از 
  cpu  
  می‌گیرد تا شانسی برای دیگر ترد‌ها برای اجرا ایجاد شود. 
  اما هیچ تضمینی وجود ندارد که کدام ترد اجرا خواهد شد. شاید حتی دوباره همان ترد قبلی اجرا شود و این موضوع به 
  Thread Scheduler 
  بستگی دارد.
</p>


<p dir="rtl">
  تفاوت 
  sleep 
  با 
  wait 
  در این است که متد 
  wait 
  بیشتر برای 
  inter-thread commiunication
  ها استفاده می‌شود به این صورت که، زمانیکه تردی یک 
  Mutable Shared data 
  را تغییر می‌دهد، ابتدا قبل از تغییر بقیه ترد‌ها را 
  wait
  کرده و پس از آنکه تغییرات را انجام داد، بقیه را 
  notify 
  کرده و با این کار می‌گوید که تغییری در داده‌های اشتراکی انجام شده که ممکن است برایتان جالب باشد.
 اما 
  sleep 
  برای متوقف کردن موقتی ترد استفاده می‌شود
</p>

<p dir="rtl">
  این تغییر زمانی واضح مشخص می‌شود که بفهمیم زمانیکه تردی
   wait 
  را صدا می‌زند، لاک یا مانیتوری که برروی آبجکت دارد را آزاد می‌کند اما زمانی که متد 
  sleep 
  از تردی 
  صدا زده می‌شود، به هیچ وجه مانیتور خود را آزاد نمی کند.
</p>

<p dir="rtl">
  یک برنامه جاوایی زمانی تمام شده و 
  exit 
  می‌شود که تمام ترد‌های آن به جز 
  Deamon
  ترد‌ها تمام شده  باشند. 
  یعنی برنامه یا پروسه برای اتمام 
  Deamon
  ترد‌ها صبر نمی‌کند. 
  ترد 
  GC  
  جاوا یک 
  Deamon
  ترد است.
</p>

<p dir="rtl">
  ما نیز می‌توانیم در برنامه‌امان 
  Deamon 
  ترد داشته باشیم.
  برای این کار کافی است متد 
  Thread.setDeamon()
  را صدا بزنیم.
  این نوع ترد‌ها زمانی به کار می‌آیند که ترد‌های غیر 
  Deamon  
  دیگری در برنامه داشته باشیم.
</p>


<p dir="rtl"><b>
لاک‌ها در جاوا
</b></p>

<p dir="rtl">
لاک‌ها برای اینکه دسترسی به یک قسمت از کد را کنترل کنند، استفاده می‌شوند.
  به این صورت که تنها یک ترد می‌تواند یک لاک را در یک زمان نگه‌دارد و بعد از آنکه لاک را آزاد کرد، آن لاک برای ترد‌ها دیگر در دسترس قرار می‌گیرد.
 اما این موضوع به این معنی نیست که آن تکه کد نمی‌توانند همزمان توسط دو ترد اجرا شود، بلکه به این معنی است که اگر آن دو ترد بر سر یک لاک منتظر باشند، آن بلاک از کد نمی‌تواند همزمان توسط دو ترد اجرا شود.
</p>


<p dir="rtl"><b>
  متد Synchronize 
</b></p>

<p dir="rtl">
  راحت‌ترین کار برای 
  synchronize 
  کردن، ایجاد یک متد 
  synchronize 
  است. 
  این کار به آن معنی است که هر زمان که تردی بخواهد این متد را صدا بزند باید ابتدا یک لاک را به دست بگیرد و بعد آن متد را اجرا کند.
  این لاک برای 
  instance 
  های معمولی آبجکت کلاس آن متد است و برای 
  static instance
  ها مانیتور مربوط به کلاس آن آبجکت‌ها است.
</p>

<p dir="rtl">
این به آن معنی نیست که این متد نمی‌تواندن به صورت همزمان توسط دو ترد اجرا شود، بلکه به این معنی است که هیچ دو تردی نمی‌توانند این متد از یک آبجکت را همزمان صدا بزنند.
  یعنی هر دو تردی می‌توانند هر تعداد بار که بخواهند این متد را از دو آبجکت متفاوت صدا بزنند.
</p>

```java

public class Point { 
  public synchronized void setXY(int x, int y) { 
    this.x = x;
    this.y = y;
  }
}

```


<p dir="rtl"><b>
   synchronized blocks
</b></p>

<p dir="rtl">
راه دوم برای آنکه قسمتی از کد را 
  synchronize 
  کنیم آن است که این کار را برای بلاکی از کد انجام دهیم.
  برای این کار باید لاکی که می‌خواهیم آن بلاک برروی آن سینک باشد را انتخاب کنیم. معمولا بهتر است از 
  this
  استفاده کنیم، هر چند که نوشتن آن اجباری نیست.
</p>

```java

public class Point { 
  public void setXY(int x, int y) { 
    synchronized (this) {
      this.x = x;
      this.y = y;
    }
  }
}

```


<p dir="rtl">
  زمانیکه از 
  this 
  استفاده می‌کنیم، به این معنی است که همان لاکی را در نظر گرفته‌ایم که متد در نظر می‌گیرد.
</p>

<p dir="rtl">
چون سینک کردن بلاک‌های کد روی پرفورمنس برنامه تاثیرگذار است، بهتر است کمترین بلاک ممکن از کد را سینک کنیم.  
</p>

<p dir="rtl">
  نکته بعدی که وجود دارد آن است که دسترسی به 
  local variable
  ها نیازی به محافظت ندارد، چون فقط از داخل خآن ترد قابل دسترسی هستند.
</p>

<p dir="rtl"><b>
Thread safe
  بودن یا نبودن، مساله این است.
</b></p>

<p dir="rtl">
Thread safe
  بودن یعنی اینکه بتوانیم از یک کلاس و از چندین ترد استفاده کنیم بدون آنکه مشکلات مطرح شده در قسمت 
  Shared Mutable Data
  را داشته باشیم. یعنی بدون آنکه نگران این باشیم که تغییر اطلاعات مشترک بین ترد‌ها باشیم از از آن‌ها در تردهای مختلف استفاده کنیم.
  از آنجایی که رسیدن به این هدف یک مقدار باعث کاهش پرفورمنس برنامه‌ها می‌شود، معمولا کلاس‌های پراستفاده در جاوا 
  Thread safe 
  نبوده و در جایی که نیاز داریم 
  Thread safe 
  باشند، باید خودمان این کار را انجام دهیم.
  به عنوان یک قانون کلی زمانی که در داکیومنت‌های یک کلاس حرفی از 
  Thread safe 
  بودن زده نشده بود، فرض ما همیشه بر این است که آن کلاس
  Thread safe
  نیست.
  کلاس‌هایی مثل 
  Collection 
  ها و ... از این دسته هستند و برای آنکه از آن‌ها محافظت کنیم باید خودمان این کار را انجام دهیم.
</p>

<p dir="rtl">
  این یک نمونه از کلاس کش هست که بررروی 
  getObject()
  و 
  clearCache()
  محافظت شده است.
</p>

```java

public class SimpleCache {
  private final Map cache = new HashMap();
 
  public Object load(String objectName) { 
    // load the object somehow
  }
 
  public void clearCache() { 
    synchronized (cache) { 
      cache.clear();
    }
  }
 
  public Object getObject(String objectName) {
    synchronized (cache) { 
      Object o = cache.get(objectName);
      if (o == null) {
        o = load(objectName);
        cache.put(objectName, o);
      }
    }
 
    return o;
  }
}

```

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>

<p dir="rtl">
</p>



منابع
---

https://www.ibm.com/developerworks/java/tutorials/j-threads/j-threads.html

https://www.geeksforgeeks.org/main-thread-java/

https://www.tutorialspoint.com/java_concurrency/index.htm
